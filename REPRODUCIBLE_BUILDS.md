# Reproducible Builds

This project is configured for reproducible builds, meaning that building from the same source code should produce byte-identical artifacts.

## What's Configured

### Archive Tasks (JAR/ZIP)
- **File timestamps disabled**: `isPreserveFileTimestamps = false`
- **Reproducible file ordering**: `isReproducibleFileOrder = true`
- **Normalized permissions**: Files set to `0644` (rw-r--r--), directories to `0755` (rwxr-xr-x)
- These settings ensure that archive metadata doesn't change between builds, regardless of source file permissions on the build machine

### Compilation
- **UTF-8 encoding**: Enforced across all compilation tasks
- **Parameter names**: `-parameters` flag ensures consistent bytecode generation
- **Java Toolchain**: Gradle manages JDK version automatically

### Build Environment
- **Build cache enabled**: `org.gradle.caching=true`
- **Locale normalization**: `user.language=en` and `user.country=US`
- **Encoding normalization**: `file.encoding=UTF-8`

## Guarantees and Limitations

### ✅ Strong Guarantees
Builds **will be reproducible** when:
- Using the same Java major version (11) via Gradle Toolchains
- Building on the same operating system type
- Using the same source code commit

### ⚠️  Partial Guarantees
Builds **should be reproducible** across:
- Different JDK patch versions (e.g., 11.0.1 vs 11.0.2) of the same vendor
- Different machines with the same OS type
- Different developers' environments

### ❌ Known Limitations
Builds **may differ** when:
1. **Different JDK vendors**: The bytecode generated by Adoptium vs Azul vs Oracle JDK may differ slightly
2. **Different OS families**: Windows vs Linux vs macOS may produce different line endings or path separators in some resources
3. **Different Gradle versions**: Although unlikely, major Gradle version changes could affect output

## Why Permission Normalization Matters

Without permission normalization:
- Files committed with different permissions (e.g., executable scripts) would produce different archives
- Builds on different file systems (ext4 vs NTFS vs APFS) could have permission variations
- Git checkout behavior regarding file permissions could affect reproducibility

With normalized permissions:
- All files in archives have consistent `0644` permissions (readable by all, writable by owner)
- All directories have `0755` permissions (executable/searchable by all, writable by owner)
- Archives are identical regardless of source file permissions on the build machine

## Maximizing Reproducibility

### Option 1: Lock JDK Vendor (Recommended for CI/CD)
Uncomment and configure in `build.gradle.kts`:
```kotlin
java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(11)
        vendor = JvmVendorSpec.ADOPTIUM // or AZUL, AMAZON, etc.
    }
}
```

### Option 2: Use Docker for Builds
Create a consistent build environment:
```dockerfile
FROM gradle:8.11.1-jdk11-alpine
WORKDIR /build
COPY . .
RUN ./gradlew clean build
```

### Option 3: Document Exact Build Environment
For maximum verifiability, document:
- JDK vendor and exact version: `java -version`
- Gradle version: `./gradlew --version`
- Operating system: `uname -a` (Linux/Mac) or `systeminfo` (Windows)

## Verification

### Quick Verification Script

The easiest way to verify reproducible builds locally:

```bash
./verify-reproducible-build.sh
```

This script will:
- Build the extension twice
- Compare checksums
- Verify file permissions (0644 for files, 0755 for directories)
- Verify timestamps are normalized
- Display results with color-coded output

### Manual Verification

To manually verify builds are reproducible:

```bash
# First build
./gradlew clean hivemqExtensionZip
shasum -a 256 build/hivemq-extension/*.zip > build1.txt

# Wait a moment (to ensure different timestamp if timestamps were included)
sleep 2

# Second build
./gradlew clean hivemqExtensionZip
shasum -a 256 build/hivemq-extension/*.zip > build2.txt

# Compare
diff build1.txt build2.txt
# No output = reproducible! ✓
```

### GitHub Actions Workflow

The project includes a GitHub Actions workflow (`.github/workflows/reproducible-build-test.yml`) that:

1. **Builds on Ubuntu (JDK 11.0.21) and macOS (JDK 11.0.25)** - Ensures cross-platform and cross-JDK-version reproducibility
2. **Compares checksums** - Verifies builds are byte-identical across platforms and JDK patch versions
3. **Validates permissions** - Confirms file/directory permissions are normalized
4. **Tests same-environment reproducibility** - Builds twice on Ubuntu and compares

**Important**: The workflow intentionally uses different JDK patch versions (11.0.21 vs 11.0.25) to prove that builds remain reproducible even with minor JDK updates. This validates that compiler changes between patch versions don't affect bytecode output.

The workflow runs automatically on:
- Pull requests to master
- Manual trigger via workflow_dispatch

**To compare your local macOS build with GitHub Actions:**

1. Push your changes to trigger the workflow
2. Wait for the workflow to complete
3. Download the `macos-build` artifact from the workflow run
4. Compare checksums:
   ```bash
   # Your local build
   shasum -a 256 build/hivemq-extension/*.zip

   # Compare with downloaded artifact
   shasum -a 256 path/to/downloaded/*.zip

   # Checksums should match!
   ```

### Verify Permissions

To inspect the permissions in the archive:

```bash
# Build the extension
./gradlew hivemqExtensionZip

# Check permissions in ZIP (detailed view)
zipinfo -l build/hivemq-extension/*.zip

# Expected output:
# drwxr-xr-x (0755) for directories
# -rw-r--r-- (0644) for files
# 80-Feb-01 00:00 for all timestamps (normalized epoch)
```

Example output:
```
drwxr-xr-x  2.0 unx        0 b- 80-Feb-01 00:00 hivemq-file-rbac-extension/
-rw-r--r--  2.0 unx 11062980 b- 80-Feb-01 00:00 hivemq-file-rbac-extension/hivemq-file-rbac-extension-4.6.4.jar
-rw-r--r--  2.0 unx     1101 b- 80-Feb-01 00:00 hivemq-file-rbac-extension/conf/config.xml
```

## Cross-Machine Verification

To verify across different machines:

```bash
# Machine 1
git checkout <commit-hash>
./gradlew clean hivemqExtensionZip
shasum -a 256 build/hivemq-extension/*.zip

# Machine 2 (same OS family, JDK 11)
git checkout <commit-hash>
./gradlew clean hivemqExtensionZip
shasum -a 256 build/hivemq-extension/*.zip

# Compare the checksums - they should match
```

## Why JDK Variations Matter

You're correct to be concerned about JDK patch versions. Here's what can vary:

1. **Compiler optimizations**: Different JDK patches may optimize string concatenation differently
2. **Bytecode generation**: Minor changes in bytecode patterns (though rare in patch versions)
3. **Standard library inlining**: Some optimizations inline standard library calls differently

However, the Gradle Toolchain feature helps because:
- It automatically downloads and uses a consistent JDK
- It caches the JDK, so the same version is reused
- It's version-specific (not just major version)

## Best Practices for This Project

1. **CI/CD**: Always use the same JDK vendor and version in CI
2. **Releases**: Build releases in CI with a documented environment
3. **Verification**: Publish checksums alongside releases
4. **Toolchain**: Consider locking the JDK vendor for critical releases

## Further Reading

- [Gradle Reproducible Builds](https://docs.gradle.org/current/userguide/working_with_files.html#sec:reproducible_archives)
- [Reproducible Builds Project](https://reproducible-builds.org/)
- [Java Toolchains](https://docs.gradle.org/current/userguide/toolchains.html)
